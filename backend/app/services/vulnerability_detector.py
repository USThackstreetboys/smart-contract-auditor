import re
import hashlib
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

from app.models.schemas import VulnerabilityReport, VulnerabilityLocation

@dataclass
class VulnerabilityPattern:
    """Pattern definition for vulnerability detection"""
    name: str
    type: str
    severity: str
    pattern: str
    description: str
    recommendation: str
    cwe_id: Optional[str] = None

class VulnerabilityDetector:
    """Pattern-based vulnerability detection for smart contracts"""
    
    def __init__(self):
        self.patterns = self._initialize_patterns()
        self.gas_patterns = self._initialize_gas_patterns()
    
    def detect_vulnerabilities(self, contract_code: str, contract_info: Dict) -> List[VulnerabilityReport]:
        """
        Main vulnerability detection function using pattern matching
        """
        vulnerabilities = []
        lines = contract_code.split('\n')
        
        # Run pattern-based detection
        vulnerabilities.extend(self._detect_reentrancy(lines, contract_info.get('name', 'Unknown')))
        vulnerabilities.extend(self._detect_access_control(lines, contract_info.get('name', 'Unknown')))
        vulnerabilities.extend(self._detect_integer_issues(lines, contract_info.get('name', 'Unknown')))
        vulnerabilities.extend(self._detect_unchecked_calls(lines, contract_info.get('name', 'Unknown')))
        vulnerabilities.extend(self._detect_gas_issues(lines, contract_info.get('name', 'Unknown')))
        vulnerabilities.extend(self._detect_logic_errors(lines, contract_info.get('name', 'Unknown')))
        
        return vulnerabilities
    
    def _initialize_patterns(self) -> List[VulnerabilityPattern]:
        """Initialize vulnerability detection patterns"""
        return [
            VulnerabilityPattern(
                name="Reentrancy Attack",
                type="Reentrancy",
                severity="CRITICAL",
                pattern=r"\.call\{value:\s*\w+\}|\.send\(|\.transfer\(",
                description="External calls before state changes enable reentrancy attacks",
                recommendation="Use reentrancy guard or checks-effects-interactions pattern",
                cwe_id="CWE-841"
            ),
            VulnerabilityPattern(
                name="Missing Access Control",
                type="Access Control",
                severity="HIGH",
                pattern=r"function\s+\w+.*\)\s+(?:external|public)(?!.*(?:onlyOwner|require|modifier))",
                description="Public/external functions lack access control",
                recommendation="Add appropriate access control modifiers",
                cwe_id="CWE-284"
            ),
            VulnerabilityPattern(
                name="Integer Overflow",
                type="Integer Overflow",
                severity="MEDIUM",
                pattern=r"(?<!SafeMath\.)\+\+|(?<!SafeMath\.)--|\+\s*=|\-\s*=|(?<!SafeMath\.)\*|(?<!SafeMath\.)/",
                description="Arithmetic operations without overflow protection",
                recommendation="Use SafeMath library or Solidity 0.8.0+ built-in checks",
                cwe_id="CWE-190"
            ),
            VulnerabilityPattern(
                name="Unchecked Call Return",
                type="Unchecked Calls",
                severity="MEDIUM",
                pattern=r"\.call\(|\.delegatecall\(|\.staticcall\(",
                description="External calls without return value verification",
                recommendation="Check return values and handle failures appropriately",
                cwe_id="CWE-252"
            )
        ]
    
    def _initialize_gas_patterns(self) -> List[VulnerabilityPattern]:
        """Initialize gas-related patterns"""
        return [
            VulnerabilityPattern(
                name="Gas Limit DoS",
                type="Gas Issues",
                severity="MEDIUM",
                pattern=r"for\s*\([^)]*\.length",
                description="Loop over dynamic array can cause gas limit issues",
                recommendation="Implement pagination or limit array size",
                cwe_id="CWE-400"
            ),
            VulnerabilityPattern(
                name="Expensive Operations",
                type="Gas Issues",
                severity="LOW",
                pattern=r"keccak256\(|sha256\(|ripemd160\(",
                description="Expensive cryptographic operations",
                recommendation="Consider gas costs in function design",
                cwe_id="CWE-400"
            )
        ]
    
    def _detect_reentrancy(self, lines: List[str], filename: str) -> List[VulnerabilityReport]:
        """Detect reentrancy vulnerabilities"""
        vulnerabilities = []
        current_function = None
        has_external_call = False
        external_call_line = 0
        state_change_after_call = False
        
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            
            # Track current function
            if re.match(r'function\s+\w+', line_stripped):
                current_function = re.search(r'function\s+(\w+)', line_stripped)
                current_function = current_function.group(1) if current_function else "unknown"
                has_external_call = False
                state_change_after_call = False
                external_call_line = 0
            
            # Check for external calls
            if re.search(r'\.call\{value:|\.send\(|\.transfer\(', line_stripped):
                has_external_call = True
                external_call_line = i + 1
            
            # Check for state changes after external call
            if has_external_call and re.search(r'\w+\s*[\+\-\*\/]?=|\w+\[.*\]\s*=', line_stripped):
                state_change_after_call = True
                
                # Found potential reentrancy
                vulnerability = VulnerabilityReport(
                    id=f"REENTRANCY_{hashlib.md5(f'{filename}_{i}'.encode()).hexdigest()[:8]}",
                    title="Reentrancy Vulnerability",
                    severity="CRITICAL",
                    type="Reentrancy",
                    description=f"State change on line {i+1} occurs after external call on line {external_call_line}, enabling reentrancy attacks",
                    location=VulnerabilityLocation(
                        file=filename,
                        startLine=external_call_line,
                        endLine=i + 1,
                        function=current_function
                    ),
                    impact="Attacker can recursively call function to drain contract funds",
                    likelihood="High if contract holds valuable assets",
                    riskScore=9.0,
                    recommendation="Move state changes before external calls or use reentrancy guard",
                    detectionMethod="Pattern Matching",
                    potentialLoss="Up to entire contract balance",
                    cweId="CWE-841",
                    references=["https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"]
                )
                vulnerabilities.append(vulnerability)
                break  # Only report once per function
        
        return vulnerabilities
    
    def _detect_access_control(self, lines: List[str], filename: str) -> List[VulnerabilityReport]:
        """Detect access control issues"""
        vulnerabilities = []
        
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            
            # Check for public/external functions without access control
            func_match = re.search(r'function\s+(\w+).*\)\s+(external|public)', line_stripped)
            if func_match:
                function_name = func_match.group(1)
                visibility = func_match.group(2)
                
                # Skip view/pure functions and constructors
                if 'view' in line_stripped or 'pure' in line_stripped or function_name == 'constructor':
                    continue
                
                # Look ahead for access control in next few lines
                has_access_control = False
                check_lines = min(5, len(lines) - i - 1)
                
                for j in range(1, check_lines + 1):
                    next_line = lines[i + j].strip()
                    if re.search(r'require\s*\(.*msg\.sender|onlyOwner|modifier\s+\w+', next_line):
                        has_access_control = True
                        break
                    if next_line.startswith('function') or next_line == '}':
                        break
                
                # Check if function performs sensitive operations
                is_sensitive = any(sensitive in function_name.lower() 
                                 for sensitive in ['withdraw', 'transfer', 'mint', 'burn', 'admin', 'owner', 'pause'])
                
                if not has_access_control and (is_sensitive or visibility == 'external'):
                    severity = "HIGH" if is_sensitive else "MEDIUM"
                    risk_score = 8.0 if is_sensitive else 5.0
                    
                    vulnerability = VulnerabilityReport(
                        id=f"ACCESS_{hashlib.md5(f'{filename}_{function_name}'.encode()).hexdigest()[:8]}",
                        title=f"Missing Access Control in {function_name}()",
                        severity=severity,
                        type="Access Control",
                        description=f"Function {function_name}() is {visibility} but lacks proper access control",
                        location=VulnerabilityLocation(
                            file=filename,
                            startLine=i + 1,
                            endLine=i + 1,
                            function=function_name
                        ),
                        impact="Unauthorized users can call sensitive functions",
                        likelihood="High - function is publicly accessible",
                        riskScore=risk_score,
                        recommendation="Add require() statements or access control modifiers",
                        detectionMethod="Pattern Matching",
                        cweId="CWE-284",
                        references=["https://docs.openzeppelin.com/contracts/4.x/access-control"]
                    )
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_integer_issues(self, lines: List[str], filename: str) -> List[VulnerabilityReport]:
        """Detect integer overflow/underflow issues"""
        vulnerabilities = []
        
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            
            # Skip if SafeMath is used or Solidity 0.8.0+
            if 'SafeMath' in line_stripped or 'pragma solidity ^0.8' in line_stripped:
                continue
            
            # Check for arithmetic operations
            arithmetic_ops = re.findall(r'(\w+)\s*([\+\-\*\/])\s*=|\w+\s*([\+\-\*\/])\s*\w+', line_stripped)
            
            if arithmetic_ops:
                vulnerability = VulnerabilityReport(
                    id=f"OVERFLOW_{hashlib.md5(f'{filename}_{i}'.encode()).hexdigest()[:8]}",
                    title="Potential Integer Overflow/Underflow",
                    severity="MEDIUM",
                    type="Integer Overflow",
                    description="Arithmetic operations without overflow protection detected",
                    location=VulnerabilityLocation(
                        file=filename,
                        startLine=i + 1,
                        endLine=i + 1
                    ),
                    impact="Integer overflow/underflow can cause unexpected behavior",
                    likelihood="Medium - depends on input validation",
                    riskScore=6.0,
                    recommendation="Use SafeMath library or upgrade to Solidity 0.8.0+",
                    detectionMethod="Pattern Matching",
                    cweId="CWE-190",
                    references=["https://docs.openzeppelin.com/contracts/4.x/utilities#math"]
                )
                vulnerabilities.append(vulnerability)
                break  # Only report once per contract
        
        return vulnerabilities
    
    def _detect_unchecked_calls(self, lines: List[str], filename: str) -> List[VulnerabilityReport]:
        """Detect unchecked external calls"""
        vulnerabilities = []
        
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            
            # Check for external calls
            call_match = re.search(r'\.call\(|\.delegatecall\(|\.staticcall\(', line_stripped)
            if call_match:
                # Check if return value is handled
                is_checked = False
                
                # Check current line for return value handling
                if re.search(r'require\s*\(.*\.call|bool\s+\w+\s*=.*\.call|\(bool\s+\w+,', line_stripped):
                    is_checked = True
                
                # Check next few lines for require() or if() statements
                if not is_checked:
                    check_lines = min(3, len(lines) - i - 1)
                    for j in range(1, check_lines + 1):
                        next_line = lines[i + j].strip()
                        if re.search(r'require\s*\(|if\s*\(', next_line):
                            is_checked = True
                            break
                
                if not is_checked:
                    vulnerability = VulnerabilityReport(
                        id=f"UNCHECKED_{hashlib.md5(f'{filename}_{i}'.encode()).hexdigest()[:8]}",
                        title="Unchecked External Call",
                        severity="MEDIUM",
                        type="Unchecked Calls",
                        description="External call return value is not verified",
                        location=VulnerabilityLocation(
                            file=filename,
                            startLine=i + 1,
                            endLine=i + 1
                        ),
                        impact="Failed external calls may go unnoticed",
                        likelihood="Medium - depends on external contract behavior",
                        riskScore=5.5,
                        recommendation="Check return value and handle failures appropriately",
                        detectionMethod="Pattern Matching",
                        cweId="CWE-252",
                        references=["https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/"]
                    )
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_gas_issues(self, lines: List[str], filename: str) -> List[VulnerabilityReport]:
        """Detect gas-related issues"""
        vulnerabilities = []
        
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            
            # Check for loops over dynamic arrays
            loop_match = re.search(r'for\s*\([^)]*\.length\)', line_stripped)
            if loop_match:
                vulnerability = VulnerabilityReport(
                    id=f"GAS_{hashlib.md5(f'{filename}_{i}'.encode()).hexdigest()[:8]}",
                    title="Gas Limit DoS Risk",
                    severity="MEDIUM",
                    type="Gas Issues",
                    description="Loop over dynamic array can cause gas limit issues",
                    location=VulnerabilityLocation(
                        file=filename,
                        startLine=i + 1,
                        endLine=i + 1
                    ),
                    impact="Function may become unusable due to gas limit",
                    likelihood="High if array grows large",
                    riskScore=6.5,
                    recommendation="Implement pagination or limit array size",
                    detectionMethod="Pattern Matching",
                    cweId="CWE-400",
                    references=["https://consensys.github.io/smart-contract-best-practices/attacks/denial-of-service/"]
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _detect_logic_errors(self, lines: List[str], filename: str) -> List[VulnerabilityReport]:
        """Detect common logic errors"""
        vulnerabilities = []
        
        for i, line in enumerate(lines):
            line_stripped = line.strip()
            
            # Check for assignment in conditions (common mistake)
            if re.search(r'if\s*\([^)]*=(?!=)[^)]*\)', line_stripped):
                vulnerability = VulnerabilityReport(
                    id=f"LOGIC_{hashlib.md5(f'{filename}_{i}'.encode()).hexdigest()[:8]}",
                    title="Assignment in Conditional",
                    severity="LOW",
                    type="Logic Error",
                    description="Assignment operator (=) used in conditional instead of comparison (==)",
                    location=VulnerabilityLocation(
                        file=filename,
                        startLine=i + 1,
                        endLine=i + 1
                    ),
                    impact="Logic error may cause unintended behavior",
                    likelihood="High if code executes this path",
                    riskScore=4.0,
                    recommendation="Use comparison operator (==) instead of assignment (=)",
                    detectionMethod="Pattern Matching",
                    cweId="CWE-480"
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities